复习
多态
1)什么多态
  一个父类的多种子类对象
  对同一个方法调用做出的不同操作
2)为什么使用多态
  为了提高程序的可扩展性
3)多态的实现步骤
  3.1)创建父类(接口),编写方法
  3.2)创建子类继承(实现)父类(接口),重写方法
  3.3)子类(实现类)对象,赋给父类(接口)引用
  3.4)使用父类(接口)引用,调用子类(实现类)方法

父类类型转换成子类类型
1)怎么实现转换
  通过强制类型转换
2)语法
  (子类类型)父类引用
3)转换过程中发生异常
  将一个非强制转换的目标类型对象
  转换为目标类型时,会发生异常
  ClassCastException
  类型转换异常

instanceof关键字
1)什么是instanceof
  判断一个对象是否属于一个类型
2)为什么使用instanceof
  在转换之前,先判断,避免类型转换异常
3)怎么使用instanceof
  <引用> instanceof <类型>
  运算结果是true或false
  一般在if的()中判断,使用

笔记
垃圾回收管理机制
1)什么是垃圾回收管理机制(GC)
  1.1)什么是垃圾
      程序中使用过的,并且之后的程序
      不会在使用的对象或资源
  1.2)什么是垃圾回收
      垃圾如果放任不管
      会逐渐占满内存,
      造成内存溢出,内存泄漏的问题
      回收垃圾,就是将不使用的资源或对象
      释放掉的操作
  1.3)垃圾回收管理机制
      就是JVM中自带的一个回收垃圾的
      线程(程序)
2)其他语言是如何回收垃圾的
  c++:没有垃圾回收机制
      程序员要编写代码来释放对象或资源
      占用的内存
      通过析构函数,来释放内存

3)垃圾回收机制的优点和不足
 优点:java程序员,不需要考虑垃圾回收的问题
 缺点:1.垃圾回收管理机制本身是占用内存的
      2.垃圾回收的时机,并不是立即的
      3.垃圾回收机制,只能回收java程序中
        产生的垃圾,
	在其他媒介中产生的垃圾要手动回收

4)垃圾的判定和原理
 4.1)判断一个对象或资源是垃圾的规则有很多
 4.2)多种规则之一:引用计数法
     内存中保存每个对象被引用的个数
     如果这个个数为0,那么即视为垃圾
 4.3)如何标记一个对象为垃圾
     <引用>=null;
 
5)finalize方法
 5.1)finalize是Object类中编写的一个方法
 5.2)这个方法会被垃圾回收管理机制
     在回收这个对象前调用

6)System.gc();
 这个方法能通知
 垃圾回收管理机制尽快回收程序中的垃圾

作业


飞机大战
第一天
创建
小敌机,大敌机,奖励机
背景,子弹,英雄机
六个类
编写属性和输出方法
在main方法中实例化测试

第二天
1.在world类中定义一个start方法
               并在main方法中调用
2.在world类中定义所有需要的对象和数组
               小敌机,大敌机,小蜜蜂
	        天空,子弹,英雄机
3.在start方法中调用输出各种对象的信息

第三天
1.创建父类飞行物 FlyingObject
  编写
  属性4个 width,height,x,y
  构造方法2个
          1.小敌机,大敌机,奖励机
	  2.天空,子弹,英雄机
2.六个子类继承FlyingObject
3.将所有子类属性中的width,height,x,y删除
4.重新编写合适的构造方法
5.使用FlyingObject[]
  替换小敌机\大敌机\奖励机的数组
  start方法中遍历元素中的show方法

第四天
1.画窗口
  让World类继承 JPanel
  在main方法中实例化窗口
  设置属性并显示
2.父类中所有属性修改为protected
  六个子类中所有属性修改为private

第五天
1.将程序需要的图片粘贴到项目中
2.在flyingobject类中,
  编写一个加载图片的方法
3.在六个子类中编写静态的图片数组
  来保存图片
  并在静态初始化块中加载需要的图片
4.在FlyingObject类中
  使用常量定义飞行物的状态
  并编写状态属性

5.在FlyingObject类中
  编写3个判断当前状态的方法

6.如果运行时发生的异常中包含信息
  input==null!
  证明加载的图片的文件名拼写有错误

第六天
1.将FlyingObject修改为抽象类
  编写两个抽象方法
  step():移动
  getImage():获得图片
2.六个子类中
  重写两个抽象方法
3.FlyingObject类中
  编写一个将图片绘制到
  窗口的方法paintObject
4.Sky类中
  重写paintObject方法
  画两张天空
5.World类中
  定义宽和高的常量
  重写paint方法
  依次将所有内容绘制到窗口
  最后运行测试

第七天
1.在World类中,编写让所有在场元素
  移动起来的方法
  编写moveAction
  在计时器中调用

2.在World类中,编写一个随机生成敌机的方法
  makeEnemy();

3.在World类中,编写敌机进场的方法
  enemyEnterAction
  并在计时器中调用
  控制敌机进场的频率
4.在Hero类中,编写英雄机开炮的方法
  shoot
  根据英雄机的火力值
  绝定时双排还是单排

第八天
1.在World类中
  编写子弹进场
  并在计时器中调用

2.创建2个接口
  创建得分接口
  创建奖励接口
3.小敌机,大敌机实现得分接口
  奖励机实现奖励接口

4.在Hero类中编写一个专门用于
  配合鼠标移动的方法
  moveTo()

5.在World类中的start方法中
  声明一个鼠标监听器重写鼠标移动方法
  并注册到鼠标移动和鼠标滑动事件中

第九天
1.在FlyingObject类中
  编写一个方法,outOfBounds
  所有子类重写这个方法
2.在World类中
  编写一个检测敌机和子弹出界的方法
  如果敌机或子弹出界
  要将出界的对象,从对应数组中移除

3.出界方法思路
  1.编写一个和源数组长度一致的数组
  2.定义一个int index=0
  3.遍历源数组,将没有出界的对象
    放入在新数组的index位置
    并且index++;
  4.新数组缩容成index的长度
   
4.FlyingObject类中
  编写判断一个碰撞的方法
  编写一个修改状态为DEAD的方法

5.Hero类中
  编写加命方法
      加火力方法
      获得命数的方法

6.World类编写一个
  hitAction方法判断场上子弹是否击中敌机
  如果击中按照游戏规则处理
  并在计时器中调用

第10天
1.Hero类中添加2个方法
  英雄机减命
  英雄机清空火力值

2.World类中编写英雄机和敌机碰撞的方法
  如果发生碰撞
  英雄机减命,减火力
  并在计时器中调用

3.World类中
  添加4个状态常量
  添加状态属性state
  添加3张图片
  静态块加载图片

4.在鼠标监听器中
  移动:添加if判断
       只在运行状态下移动
  点击:开始状态切换到运行状态
       结束状态切换到开始状态
  移出:如果是运行状态,切换到暂停状态
  移入:如果是暂停状态,切换到运行状态

5.计时器
  除repaint方法外
  其他所有方法均在运行状态下才能运行

6.编写一个游戏结束的判断
  gameOverAction
  并在计时器中调用

7.在repaint方法中
  编写一个多分支结构
  在不同状态下画不同的状态图






草稿

Dog d=(Dog)p;
d.catchFlyDisc();

((Dog)p).catchFlyDisc();

Pet p=new Cat();

if(p instanceof Dog){
    Dog d=(Dog)p;
}


class Aoo{

    public void aa(){
       syso("123");
       bb();
       syso("456");
    }
    public void bb(){
       Dog d=new Dog();
       ..
    }
}

class Aoo{

  public void abc(){
      Dog d=new Dog();
      //标记d为垃圾
      //将d对象的引用减少为0
      d=null;
	
	...
      1000多行
      从没有使用到d
      这个情况就需要在使用完
      d对象之后,标记它为垃圾
  }



}








